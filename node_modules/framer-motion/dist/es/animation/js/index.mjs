import { keyframes } from '../generators/keyframes.mjs';
import { spring } from '../generators/spring/index.mjs';
import { inertia } from '../generators/inertia.mjs';
import { frameloopDriver } from './driver-frameloop.mjs';
import { interpolate } from '../../utils/interpolate.mjs';
import { clamp } from '../../utils/clamp.mjs';
import { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';

const types = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes: keyframes,
    spring,
};
/**
 * Implement a practical max duration for keyframe generation
 * to prevent infinite loops
 */
const maxDuration = 20000;
function calculateDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state = generator.next(duration);
    while (!state.done && duration < maxDuration) {
        duration += timeStep;
        state = generator.next(duration);
    }
    return duration;
}
function animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options }) {
    let resolveFinishedPromise;
    let currentFinishedPromise;
    /**
     * Create a new finished Promise every time we enter the
     * finished state and resolve the old Promise. This is
     * WAAPI-compatible behaviour.
     */
    const updateFinishedPromise = () => {
        currentFinishedPromise = new Promise((resolve) => {
            resolveFinishedPromise = resolve;
        });
    };
    // Create the first finished promise
    updateFinishedPromise();
    let animationDriver;
    const generatorFactory = types[type] || keyframes;
    /**
     * If this isn't the keyframes generator and we've been provided
     * strings as keyframes, we need to interpolate these.
     * TODO: Support velocity for units and complex value types/
     */
    let mapNumbersToKeyframes;
    if (generatorFactory !== keyframes &&
        typeof keyframes$1[0] !== "number") {
        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {
            clamp: false,
        });
        keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
    let mirroredGenerator;
    if (repeatType === "mirror") {
        mirroredGenerator = generatorFactory({
            ...options,
            keyframes: [...keyframes$1].reverse(),
            velocity: -(options.velocity || 0),
        });
    }
    let playState = "idle";
    let holdTime = null;
    let startTime = null;
    /**
     * If duration is undefined and we have repeat options,
     * we need to calculate a duration from the generator.
     *
     * We set it to the generator itself to cache the duration.
     * Any timeline resolver will need to have already precalculated
     * the duration by this step.
     */
    if (generator.calculatedDuration === null && repeat) {
        generator.calculatedDuration = calculateDuration(generator);
    }
    const { calculatedDuration } = generator;
    let resolvedDuration = Infinity;
    let totalDuration = Infinity;
    if (calculatedDuration) {
        resolvedDuration = calculatedDuration + repeatDelay;
        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    }
    let time = 0;
    const tick = (timestamp) => {
        if (startTime === null)
            return;
        if (holdTime !== null) {
            time = holdTime;
        }
        else {
            time = timestamp - startTime;
        }
        // Rebase on delay
        time = Math.max(time - delay, 0);
        /**
         * If this animation has finished, set the current time
         * to the total duration.
         */
        if (playState === "finished" && holdTime === null) {
            time = totalDuration;
        }
        let elapsed = time;
        let frameGenerator = generator;
        if (repeat) {
            /**
             * Get the current progress (0-1) of the animation. If t is >
             * than duration we'll get values like 2.5 (midway through the
             * third iteration)
             */
            const progress = time / resolvedDuration;
            /**
             * Get the current iteration (0 indexed). For instance the floor of
             * 2.5 is 2.
             */
            let currentIteration = Math.floor(progress);
            /**
             * Get the current progress of the iteration by taking the remainder
             * so 2.5 is 0.5 through iteration 2
             */
            let iterationProgress = progress % 1.0;
            /**
             * If iteration progress is 1 we count that as the end
             * of the previous iteration.
             */
            if (!iterationProgress && progress >= 1) {
                iterationProgress = 1;
            }
            iterationProgress === 1 && currentIteration--;
            /**
             * Reverse progress if we're not running in "normal" direction
             */
            const iterationIsOdd = currentIteration % 2;
            if (iterationIsOdd) {
                if (repeatType === "reverse") {
                    iterationProgress = 1 - iterationProgress;
                    if (repeatDelay) {
                        iterationProgress -= repeatDelay / resolvedDuration;
                    }
                }
                else if (repeatType === "mirror") {
                    frameGenerator = mirroredGenerator;
                }
            }
            const p = time >= totalDuration
                ? repeatType === "reverse" && iterationIsOdd
                    ? 0
                    : 1
                : clamp(0, 1, iterationProgress);
            elapsed = p * resolvedDuration;
        }
        const state = frameGenerator.next(elapsed);
        let { value, done } = state;
        if (onUpdate) {
            onUpdate(mapNumbersToKeyframes ? mapNumbersToKeyframes(value) : value);
        }
        if (calculatedDuration !== null) {
            done = time >= totalDuration;
        }
        const isAnimationFinished = holdTime === null &&
            (playState === "finished" || (playState === "running" && done));
        if (isAnimationFinished) {
            finish();
        }
        return state;
    };
    const finish = () => {
        animationDriver && animationDriver.stop();
        playState = "finished";
        onComplete && onComplete();
        resolveFinishedPromise();
        updateFinishedPromise();
    };
    const play = () => {
        if (!animationDriver)
            animationDriver = driver(tick);
        const now = animationDriver.now();
        onPlay && onPlay();
        playState = "running";
        if (holdTime !== null) {
            startTime = now - holdTime;
        }
        else if (!startTime) {
            // TODO When implementing play/pause, check WAAPI
            // logic around finished animations
            startTime = now;
        }
        holdTime = null;
        animationDriver.start();
    };
    if (autoplay) {
        play();
    }
    const controls = {
        then(resolve, reject) {
            return currentFinishedPromise.then(resolve, reject);
        },
        get time() {
            return millisecondsToSeconds(time);
        },
        set time(newTime) {
            const timeInMs = secondsToMilliseconds(newTime);
            if (holdTime !== null || !animationDriver) {
                holdTime = timeInMs;
            }
            else {
                startTime = animationDriver.now() - timeInMs;
            }
        },
        play,
        pause: () => {
            playState = "paused";
            holdTime = time;
        },
        stop: () => {
            onStop && onStop();
            animationDriver && animationDriver.stop();
            animationDriver = undefined;
        },
        sample: (elapsed) => {
            startTime = 0;
            return tick(elapsed);
        },
    };
    return controls;
}

export { animateValue };
